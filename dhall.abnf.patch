--- dhall-lang/standard/dhall.abnf	2018-10-28 13:45:12.120838960 +0100
+++ dhall.abnf	2018-11-07 20:32:18.167987916 +0100
@@ -116,9 +116,9 @@
     / line-comment
     / block-comment
 
-whitespace = *whitespace-chunk
+whitespace = "" / whitespace whitespace-chunk
 
-nonempty-whitespace = 1*whitespace-chunk
+nonempty-whitespace = whitespace whitespace-chunk
 
 ; Uppercase or lowercase ASCII letter
 ALPHA = %x41-5A / %x61-7A
@@ -366,7 +366,7 @@
 
 natural-literal = natural-raw whitespace
 
-identifier = label [ at natural-raw whitespace ]
+identifier = label / label at natural-raw whitespace
 
 identifier-reserved-prefix =
     reserved-raw 1*(ALPHA / DIGIT / "-" / "/" / "_") whitespace [ at natural-raw whitespace ]
@@ -439,7 +439,7 @@
 
 userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
 
-host = IP-literal / IPv4address / reg-name
+host = IP-literal / reg-name
 
 port = *DIGIT
 
@@ -593,7 +593,8 @@
 annotated-expression =
     ; "merge e1 e2 : t"
     ; "merge e1 e2"
-      merge import-expression import-expression [ colon application-expression ]
+      merge import-expression import-expression
+    / merge import-expression import-expression colon application-expression
 
     ; "[]  : List     t"
     ; "[]  : Optional t"
@@ -602,35 +603,34 @@
     ; NOTE: Backtrack if parsing this alternative fails since we can't tell
     ; from the opening bracket whether or not this will be an empty list or
     ; non-empty list
-    / open-bracket (empty-collection / non-empty-optional)
+    / open-bracket close-bracket colon List import-expression
+    / open-bracket close-bracket colon Optional import-expression
+    / open-bracket expression close-bracket colon Optional import-expression
 
     ; "x : t"
-    / operator-expression (colon expression / "")
-
-empty-collection = close-bracket colon (List / Optional) import-expression
-
-non-empty-optional = expression close-bracket colon Optional import-expression
+    / operator-expression colon expression
+    / operator-expression
 
 operator-expression = import-alt-expression
 
-import-alt-expression    = or-expression            *(import-alt            or-expression)
-or-expression            = plus-expression          *(or                    plus-expression         )
-plus-expression          = text-append-expression   *(plus whitespace-chunk text-append-expression  )
-text-append-expression   = list-append-expression   *(text-append           list-append-expression  )
-list-append-expression   = and-expression           *(list-append           and-expression          )
-and-expression           = combine-expression       *(and                   combine-expression      )
-combine-expression       = prefer-expression        *(combine               prefer-expression       )
-prefer-expression        = combine-types-expression *(prefer                combine-types-expression)
-combine-types-expression = times-expression         *(combine-types         times-expression        )
-times-expression         = equal-expression         *(times                 equal-expression        )
-equal-expression         = not-equal-expression     *(double-equal          not-equal-expression    )
-not-equal-expression     = application-expression   *(not-equal             application-expression  )
+import-alt-expression    = or-expression            / import-alt-expression import-alt or-expression
+or-expression            = plus-expression          / or-expression or plus-expression
+plus-expression          = text-append-expression   / plus-expression plus whitespace-chunk text-append-expression
+text-append-expression   = list-append-expression   / text-append-expression text-append list-append-expression
+list-append-expression   = and-expression           / list-append-expression list-append and-expression
+and-expression           = combine-expression       / and-expression and combine-expression
+combine-expression       = prefer-expression        / combine-expression combine prefer-expression
+prefer-expression        = combine-types-expression / prefer-expression prefer combine-types-expression
+combine-types-expression = times-expression         / combine-types-expression combine-types times-expression
+times-expression         = equal-expression         / times-expression times equal-expression
+equal-expression         = not-equal-expression     / equal-expression double-equal not-equal-expression
+not-equal-expression     = constructors-or-some-expression / not-equal-expression not-equal constructors-or-some-expression
 
 ; Import expressions need to be separated by some whitespace, otherwise there
 ; would be ambiguity: `./ab` could be interpreted as "import the file `./ab`",
 ; or "apply the import `./a` to label `b`"
-application-expression =
-    [ constructors / Some ] import-expression *(whitespace-chunk import-expression)
+constructors-or-some-expression = [ constructors / Some ] application-expression
+application-expression = import-expression / application-expression whitespace-chunk import-expression
 
 import-expression = import / selector-expression
 
@@ -642,7 +642,7 @@
 ; can't tell from parsing just the period whether "foo." will become "foo.bar"
 ; (i.e. accessing field `bar` of the record `foo`) or `foo./bar` (i.e. applying
 ; the function `foo` to the relative path `./bar`)
-selector-expression = primitive-expression *(dot ( label / labels ))
+selector-expression = primitive-expression / selector-expression dot ( label / labels )
 
 ; NOTE: Backtrack when parsing the first three alternatives (i.e. the numeric
 ; literals).  This is because they share leading characters in common
@@ -703,14 +703,9 @@
 
 record-type-or-literal =
       equal                             ; Empty record literal
-    / non-empty-record-type-or-literal
     / ""                                ; Empty record type
-
-non-empty-record-type-or-literal =
-    label (non-empty-record-literal / non-empty-record-type)
-
-non-empty-record-type    = colon expression *(comma label colon expression)
-non-empty-record-literal = equal expression *(comma label equal expression)
+    / label colon expression *(comma label colon expression) ; nonempty record type
+    / label equal expression *(comma label equal expression) ; nonempty record literal
 
 union-type-or-literal =
       non-empty-union-type-or-literal
